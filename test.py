import random
from neo4j import GraphDatabase
from langchain_community.llms import Ollama
import ollama
import PyPDF2
import chainlit as cl
from langchain_ollama import OllamaEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma
from langchain.chains import ConversationalRetrievalChain
from langchain_community.chat_message_histories import ChatMessageHistory
from langchain.memory import ConversationBufferMemory
from dotenv import load_dotenv
import os
import random
import pytesseract
from pdf2image import convert_from_path
from PIL import Image
import json
chatCount = 0

# Connexion √† Neo4j
uri = "bolt://localhost:7687"
username = "neo4j"
password = "12345678"



try:
    driver = GraphDatabase.driver(uri, auth=(username, password))
    with driver.session() as session:
        
        result = session.run("RETURN 1 AS test")
        for record in result:
            print("Connexion r√©ussie:", record["test"])
except Exception as e:
    print("Erreur de connexion √† Neo4j:", e)

# Initialisation du mod√®le LLM
load_dotenv()

from langchain_ollama import OllamaLLM
llm = OllamaLLM(model="mistral")

def extract_text_from_pdf(file_path):
    """
    Extrait le texte du fichier PDF. Si le PDF contient uniquement des images, l'OCR est utilis√© pour extraire le texte des images.
    Si le PDF contient √† la fois du texte et des images, le texte est extrait et l'OCR est appliqu√© aux pages sans texte.
    
    :param file_path: Chemin vers le fichier PDF.
    :return: Le texte extrait du PDF.
    """
    pdf = PyPDF2.PdfReader(file_path)
    pdf_text = ""
    images = convert_from_path(file_path)
    ocr_text = ""
    
    for page_number, page in enumerate(pdf.pages):
        # Tenter d'extraire le texte
        text = page.extract_text()
        if text:
            pdf_text += text
        else:
            # Si aucun texte n'est extrait, appliquer l'OCR sur l'image de cette page
            print(f"Pas de texte trouv√© sur la page {page_number + 1}, tentative d'OCR.")
            img = images[page_number]
            ocr_text += pytesseract.image_to_string(img)
    
    full_text = pdf_text + "\n" + ocr_text
    # Si le texte extrait est vide, retournez une indication
    if not full_text.strip():
        return None  # Indique que le PDF ne contient pas de texte
    return full_text


@cl.action_callback("generate_examples")
async def generate_examples(action):
    chain = cl.user_session.get("chain")
    random_seed = random.randint(1, 100)
    text = cl.user_session.get("full_pdf_text")
    prompt = (f"Using seed {random_seed}, generate exactly 5 creative examples that illustrate key concepts from the text.\n\n{text}")
    res = await chain.acall({"question": prompt}, callbacks=[cl.AsyncLangchainCallbackHandler()])
    await cl.Message(content=res["answer"]).send()

@cl.action_callback("generate_quiz")
async def generate_quiz(action):
    chain = cl.user_session.get("chain")
    random_seed = random.randint(1, 100)
    text = cl.user_session.get("full_pdf_text")
    prompt = (f"Using seed {random_seed}, generate exactly 5 quiz questions. Each should have one correct answer, "
              f"three incorrect alternatives, and an explanation for the correct choice.\n\n{text}")
    res = await chain.acall({"question": prompt}, callbacks=[cl.AsyncLangchainCallbackHandler()])
    await cl.Message(content=res["answer"]).send()

@cl.action_callback("generate_questions")
async def generate_questions(action):
    chain = cl.user_session.get("chain")
    themes = ["Factual Details", "Interpretative Insights", "Critical Evaluations"]
    random_theme = random.choice(themes)
    random_seed = random.randint(1, 100)
    text = cl.user_session.get("full_pdf_text")
    prompt = (f"Using seed {random_seed}, generate 5 unique questions focusing on '{random_theme}'.\n\n{text}")
    res = await chain.acall({"question": prompt}, callbacks=[cl.AsyncLangchainCallbackHandler()])
    await cl.Message(content=res["answer"]).send()

@cl.action_callback("generate_explanation")
async def generate_explanation(action):
    chain = cl.user_session.get("chain")
    text = cl.user_session.get("full_pdf_text")
    prompt = ("Provide a detailed and pedagogical explanation of a key concept from the text.\n\n" + text)
    res = await chain.acall({"question": prompt}, callbacks=[cl.AsyncLangchainCallbackHandler()])
    answer = res["answer"]
    sources = "\n\nSources:\n" + "\n".join([f"- {doc.metadata['source']}" for doc in res["source_documents"]])
    await cl.Message(content=answer + sources).send()

@cl.on_message
async def main(message: cl.Message):
    global chatCount 
    chatCount += 1
    if chatCount > 5:
        print("Limite de messages atteinte.")
    chain = cl.user_session.get("chain")
    cb = cl.AsyncLangchainCallbackHandler()
    
    res = await chain.acall({"question": message.content}, callbacks=[cb])
    answer = res["answer"]
    sources = res["source_documents"]
    
    sources_content = "\n\nSources:\n" + "\n".join([f"- {doc.metadata['source']}" for doc in sources]) if sources else ""
    await cl.Message(content=answer + sources_content).send()


# ---------------------------
# Fonctions base de donn√©es
# ---------------------------
def get_random_concepts(tx):
    query = """
    MATCH (c:Concept)
    WHERE c.name IS NOT NULL AND c.known = 0
    RETURN c.name AS concept
    ORDER BY rand()
    LIMIT 5
    """
    result = tx.run(query)
    return [record["concept"] for record in result]

def get_prerequisites(tx, concept):
    query = """
    MATCH (c:Concept)-[:PREREQUISITE]->(p:Concept)
    WHERE c.name = $concept
    RETURN p.name AS prerequisite
    """
    result = tx.run(query, concept=concept)
    return [record["prerequisite"] for record in result]

def get_all_concepts(tx):
    query = """
    MATCH (c:Concept)
    WHERE c.name IS NOT NULL 
    RETURN c.name AS concept
    ORDER BY rand()
    """
    result = tx.run(query)
    return [record["concept"] for record in result]

# ---------------------------
# Chat start
# ---------------------------
@cl.on_chat_start
async def on_chat_start():
    with driver.session() as session:
        concepts = session.read_transaction(get_random_concepts)

    if not concepts:
        await cl.Message("Aucun concept trouv√© dans la base de donn√©es.").send()
        await handle_pdf_upload()
        return

    cl.user_session.set("concepts", concepts)
    cl.user_session.set("current_index", 0)

    await ask_concept_question()



# ---------------------------
# √âtape 1 : Demande initiale
# ---------------------------

async def ask_concept_question():
    concepts = cl.user_session.get("concepts")
    index = cl.user_session.get("current_index")

    if index >= len(concepts):
        await cl.Message("üéì Tu as termin√© tous les concepts ! Place maintenant √† l'analyse du PDF.").send()  
        await handle_pdf_upload()
        return

    concept = concepts[index]
    await cl.Message(
        content=f"Connais-tu le concept suivant : **{concept}** ? (Oui/Non)",
        actions=[
            cl.Action(name="yes", label="Oui", payload={"known": True}),
            cl.Action(name="no", label="Non", payload={"known": False})
        ]
    ).send()

# ---------------------------
# Si connu
# ---------------------------
@cl.action_callback("yes")
async def handle_known_concept(action):
    # R√©cup√©rer le concept actuel
    concepts = cl.user_session.get("concepts")
    index = cl.user_session.get("current_index")
    concept = concepts[index]

    # Mise √† jour de la propri√©t√© 'known' √† 1 dans Neo4j
    try:
        with driver.session() as session:
            session.run("""
                MATCH (c:Concept)
                WHERE c.name = $concept
                SET c.known = 1
            """, concept=concept)
        await cl.Message("Parfait ! ‚úÖ Passons au suivant.").send()
    except Exception as e:
        await cl.Message(f"‚ö†Ô∏è Erreur lors de la mise √† jour du concept : {e}").send()

    # Passer au concept suivant
    cl.user_session.set("current_index", cl.user_session.get("current_index") + 1)
    
    await ask_concept_question()

# ---------------------------
# Si inconnu ‚Üí Explication + Quiz
# ---------------------------
@cl.action_callback("no")
async def handle_unknown_concept(action):
    concepts = cl.user_session.get("concepts")
    index = cl.user_session.get("current_index")
    concept = concepts[index]

    with driver.session() as session:
        prerequisites = session.read_transaction(get_prerequisites, concept)

    prereq_text = (
        f"""
        Pour bien comprendre le concept ¬´¬†{concept}¬†¬ª, il est essentiel de ma√Ætriser certains pr√©requis √©troitement li√©s √† ce sujet. 
        Voici les pr√©requis pertinents : {', '.join(prerequisites)}.
        Pour chaque pr√©requis identifi√© :
        - Pr√©sente uniquement les aspects directement utiles pour comprendre le concept ¬´¬†{concept}¬†¬ª.
        - Donne un exemple concret ou une analogie en lien direct avec le concept pour illustrer ces aspects.
        - Concentre-toi sur les notions cl√©s permettant de faire le lien entre ce pr√©requis et le concept.
        - Propose une ressource cibl√©e (article, tutoriel ou vid√©o) permettant d‚Äôapprofondir sp√©cifiquement ce pr√©requis dans le contexte du concept ¬´¬†{concept}¬†¬ª.
        """
        if prerequisites
        else "Ce concept ne n√©cessite aucun pr√©requis particulier.\n")


    concept_text = f"""
    Explique maintenant le concept '{concept}' de mani√®re claire, cibl√©e et p√©dagogique :
    
    - D√©cris les id√©es cl√©s du concept : √† quoi il sert, pourquoi il est important, et dans quels contextes on l‚Äôutilise.
    - D√©taille uniquement les usages les plus pertinents pour un √©tudiant d√©butant ou en difficult√©.
    - Utilise des exemples ou analogies en lien avec les pr√©requis mentionn√©s pr√©c√©demment.
    - Montre les erreurs fr√©quentes ou confusions possibles √† √©viter.
    - Sugg√®re 1 ou 2 ressources bien choisies pour renforcer la compr√©hension et pratiquer le concept efficacement."""

    quiz_prompt = f"""
    G√©n√®re 3 questions Vrai/Faux au FORMAT JSON STRICT pour '{concept}'.
    Respecte scrupuleusement :
    - Guillemets doubles uniquement
    - Pas de texte hors JSON
    - R√©ponses uniquement 'Vrai'/'Faux'
    - Questions courtes (<20 mots)
    
    Exemple VALIDE :
    {{
        "quiz": [
            {{
                "question": "Le HTTP utilise le port 80 par d√©faut",
                "answer": "Vrai"
            }},
            {{
                "question": "SSL et TLS d√©signent le m√™me protocole",
                "answer": "Faux"
            }}
        ]
    }}"""

    try:
        # G√©n√©ration des contenus
        explanation = await cl.make_async(llm.invoke)(prereq_text + "\n\n" + concept_text)
        quiz_response = await cl.make_async(llm.invoke)(quiz_prompt)

        # Nettoyage du JSON
        quiz_json = quiz_response.strip()
        quiz_json = quiz_json.replace("‚Äú", '"').replace("‚Äù", '"') 
        
        # Extraction du JSON depuis les blocs Markdown
        if '```json' in quiz_json:
            quiz_json = quiz_json.split('```json')[1].split('```')[0]
        
        # Correction automatique des virgules manquantes
        quiz_json = quiz_json.replace('}{', '},{').replace('}\n{', '},\n{')
        
        # Validation et parsing
        try:
            data = json.loads(quiz_json)
            quiz_data = data.get("quiz", [])
            
            if not isinstance(quiz_data, list):
                raise ValueError("Structure 'quiz' invalide")
                
            # Validation des questions
            for i, q in enumerate(quiz_data):
                if not isinstance(q, dict):
                    raise ValueError(f"Question {i+1} n'est pas un objet")
                if 'question' not in q or 'answer' not in q:
                    raise ValueError(f"Question {i+1} manque des champs requis")
                
                # Normalisation des r√©ponses
                q['answer'] = q['answer'].strip().title()
                if q['answer'] not in ['VRAI', 'FAUX']:
                    q['answer'] = 'Vrai'  # Valeur par d√©faut s√©curis√©e

        except Exception as e:
            # Fallback en cas d'erreur persistante
            quiz_data = [{
                "question": f"Question {i+1} (Erreur technique)",
                "answer": "Vrai"
            } for i in range(3)]
            
            await cl.Message(
                f"‚ö†Ô∏è Probl√®me de formatage du quiz. Erreur : {str(e)}\n"
                f"R√©ponse brute du mod√®le :\n{quiz_response}"
            ).send()

        # Affichage avec payload corrig√©
        await cl.Message(
            content=f"üìò **{concept}**\n{explanation.strip()}",
            actions=[
                cl.Action(name="generate_quiz", label="üß† G√©n√©rer un nouveau quiz", payload={"concept": concept}),
                cl.Action(name="more_examples", label="üí° Plus d'exemples", payload={"concept": concept})
            ]
        ).send()

        # Sauvegarde des donn√©es
        cl.user_session.set("current_quiz", quiz_data)
        cl.user_session.set("quiz_index", 0)
        cl.user_session.set("quiz_score", 0)
        
        await send_quiz_question()

    except Exception as e:
        await cl.Message(
            f"‚ö†Ô∏è Erreur lors de la g√©n√©ration : {str(e)}\n"
            "Nous passons au concept suivant."
        ).send()
        cl.user_session.set("current_index", index + 1)
        await ask_concept_question()@cl.action_callback("no")


# ---------------------------
# Envoyer une question du quiz
# ---------------------------
async def send_quiz_question():
    quiz = cl.user_session.get("current_quiz")
    index = cl.user_session.get("quiz_index")

    if index >= len(quiz):
        score = cl.user_session.get("quiz_score")
        total = len(quiz)

        result_msg = f"‚úÖ Tu as bien compris ! Score : {score}/{total}" if score == total else f"üìò Tu as eu {score}/{total}. Continue de r√©viser !"
        await cl.Message(result_msg).send()

        # Si toutes les questions sont r√©pondues correctement, mettre √† jour le concept comme "connu"
        if score == total:
            concepts = cl.user_session.get("concepts")
            current_index = cl.user_session.get("current_index")
            if current_index < len(concepts):
                concept = concepts[current_index]
                try:
                    with driver.session() as session:
                        session.run("""
                            MATCH (c:Concept)
                            WHERE c.name = $concept
                            SET c.known = 1
                        """, concept=concept)
                    await cl.Message(f"üéì Le concept '{concept}' est maintenant marqu√© comme connu.").send()
                except Exception as e:
                    await cl.Message(f"‚ö†Ô∏è Erreur lors de la mise √† jour du concept : {e}").send()

        # Passer au concept suivant
        cl.user_session.set("current_index", cl.user_session.get("current_index") + 1)

        # V√©rifier si tous les concepts ont √©t√© vus
        concepts = cl.user_session.get("concepts")
        current_index = cl.user_session.get("current_index")

        if current_index >= len(concepts):
            await cl.Message("üéì Tu as termin√© tous les concepts ! Place maintenant √† l'analyse du PDF.").send()
            await handle_pdf_upload()  # Lance l'analyse du PDF
        else:
            await ask_concept_question()
        return

    question = quiz[index]["question"]
    await cl.Message(
        content=f"‚ùì **Question {index+1} :** {question}",
        actions=[
            cl.Action(name="true", label="Vrai", payload={"response": "Vrai"}),
            cl.Action(name="false", label="Faux", payload={"response": "Faux"})
        ]
    ).send()

# ---------------------------
# R√©ponse au quiz
# ---------------------------
@cl.action_callback("true")
async def answer_true(action):
    await handle_quiz_response("Vrai")

@cl.action_callback("false")
async def answer_false(action):
    await handle_quiz_response("Faux")

async def handle_quiz_response(user_answer):
    quiz = cl.user_session.get("current_quiz")
    index = cl.user_session.get("quiz_index")
    correct = quiz[index]["answer"]

    if user_answer.lower() == correct.lower():
        await cl.Message("‚úÖ Bonne r√©ponse !").send()
        cl.user_session.set("quiz_score", cl.user_session.get("quiz_score") + 1)
    else:
        await cl.Message(f"‚ùå Mauvaise r√©ponse. La bonne r√©ponse √©tait **{correct}**.").send()

    cl.user_session.set("quiz_index", index + 1)
    await send_quiz_question()

# ---------------------------
# Lancer l'analyse du PDF apr√®s la fin des quiz
# ---------------------------
async def handle_pdf_upload():
  
    
    files = None
    
    # Demande d'upload de fichier
    while files is None:
        files = await cl.AskFileMessage(
            content="üìÑ Veuillez uploader un fichier PDF pour commencer !",
            accept=["application/pdf"],
            max_size_mb=100,
            timeout=180
        ).send()

    file = files[0]
    pdf_text = extract_text_from_pdf(file.path)

    if not pdf_text:
        await cl.Message(content="‚ö†Ô∏è Le PDF t√©l√©charg√© ne contient pas de texte exploitable. Veuillez essayer avec un autre fichier.").send()
        return

    # D√©coupage du texte
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=1200, chunk_overlap=50)
    texts = text_splitter.split_text(pdf_text)
    metadatas = [{"source": f"{i}-pl"} for i in range(len(texts))]

    # Embedding & indexation
    persist_dir = "./chroma_db"
    embeddings = OllamaEmbeddings(model="nomic-embed-text")
    docsearch = await cl.make_async(Chroma.from_texts)(
        texts, 
        embeddings, 
        metadatas=metadatas,
        persist_directory=persist_dir ) # Ajout crucial
    docsearch.persist()

    # M√©moire de conversation
    memory = ConversationBufferMemory(
        memory_key="chat_history",
        output_key="answer",
        chat_memory=ChatMessageHistory(),
        return_messages=True,
    )

    # Cr√©ation de la cha√Æne de QA
    chain = ConversationalRetrievalChain.from_llm(
        llm=llm,
        chain_type="stuff",
        retriever=docsearch.as_retriever(),
        memory=memory,
        return_source_documents=True
    )
    cl.user_session.set("chain", chain)

    # Message d‚Äôattente pour l‚Äôanalyse du PDF
    wait_message = await cl.Message("üîç Analyse du PDF en cours...").send()

    # R√©sum√© du contenu
    summary_prompt = f"""
    Fais un r√©sum√© structur√© et concis du texte suivant, en mettant en valeur les concepts cl√©s et id√©es principales :
    {pdf_text}
    """
    summary = await cl.make_async(llm.invoke)(summary_prompt)

    # R√©cup√©ration de tous les concepts
    with driver.session() as session:
        concepts = session.read_transaction(get_all_concepts)
    cl.user_session.set("concepts", concepts)

    matched_concepts = set()

    # D√©tection des concepts mentionn√©s dans le r√©sum√©
    for concept in concepts:
        prompt = f"""
        Analyse ce r√©sum√© et d√©termine s'il mentionne ou traite du concept \"{concept}\".
        R√©ponds uniquement par 'Oui' ou 'Non'.

        R√©sum√© :
        {summary}
        """
        try:
            response = await cl.make_async(llm.invoke)(prompt)
            if "oui" in response.strip().lower():
                matched_concepts.add(concept)

                with driver.session() as session:
                    result = session.run("MATCH (c:Concept) WHERE c.name = $concept RETURN c.known AS known", concept=concept)
                    known = result.single()["known"]

                explanation_prompt = f"""
                Explique le concept '{concept}' de mani√®re claire et accessible :
                - Pr√©cise √† quoi il sert et pourquoi il est important.
                - Utilise des exemples concrets et des analogies.
                - Propose des ressources pour approfondir.
                """

                if known == 0:
                    with driver.session() as session:
                        prerequisites = session.read_transaction(get_prerequisites, concept)

                    if prerequisites:
                        
                        prereq_text = ( f"""
                                       Pour bien comprendre le concept ¬´¬†{concept}¬†¬ª, il est essentiel de ma√Ætriser certains pr√©requis √©troitement li√©s √† ce sujet.
                                       Voici les pr√©requis pertinents : {', '.join(prerequisites)}.
                                       Pour chaque pr√©requis identifi√© :
                                       - Pr√©sente uniquement les aspects directement utiles pour comprendre le concept ¬´¬†{concept}¬†¬ª.
                                       - Donne un exemple concret ou une analogie en lien direct avec le concept pour illustrer ces aspects.
                                       - Concentre-toi sur les notions cl√©s permettant de faire le lien entre ce pr√©requis et le concept.
                                       - Propose une ressource cibl√©e (article, tutoriel ou vid√©o) permettant d‚Äôapprofondir sp√©cifiquement ce pr√©requis dans le contexte du concept ¬´¬†{concept}¬†¬ª.
                                       """
                                       if prerequisites
                                       else "Ce concept ne n√©cessite aucun pr√©requis particulier.\n")

                    else:
                        prereq_text = "Ce concept ne n√©cessite aucun pr√©requis particulier.\n"

                    explanation_text = prereq_text + "\n\n" + explanation_prompt
                elif known == 1 :
                    explanation_text = explanation_prompt

                explanation = await cl.make_async(llm.invoke)(explanation_text)
                await cl.Message(f"üìò **Explication de {concept}**\n\n{explanation.strip()}").send()

        except Exception as e:
            print(f"‚ùå Erreur lors de la v√©rification du concept '{concept}' : {e}")

    await wait_message.remove()

    if matched_concepts:
        cl.user_session.set("matched_concepts", matched_concepts)

        # G√©n√©ration du quiz
        quiz_prompt = f"""
        G√©n√®re 5 questions de quiz √† choix multiples (QCM), chacune portant sur un des concepts suivants : {', '.join(matched_concepts)}.
        Pour chaque question :
        - Propose une bonne r√©ponse et trois distracteurs plausibles.
        - N'indique PAS la bonne r√©ponse.
        - Utilise un format clair comme :
        **Question 1 :** Quel est le r√¥le de XYZ ?
        A. R√©ponse plausible
        B. R√©ponse plausible
        C. R√©ponse plausible
        D. R√©ponse plausible
        Adapte la langue du quiz √† celle des concepts si besoin.
        """

        quiz_output = await cl.make_async(llm.invoke)(quiz_prompt)
        await cl.Message(f"üß† **Quiz bas√© sur les concepts d√©tect√©s :**\n\n{quiz_output.strip()}").send()
    else:
        await cl.Message("‚ùå Aucun concept d√©tect√© dans ce document.").send()

    cl.user_session.set("full_pdf_text", pdf_text)
    
    await cl.Message("üéì Le PDF a √©t√© trait√©. Vous pouvez maintenant poser vos questions !").send()

    
              

  
   

   